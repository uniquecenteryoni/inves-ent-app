import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from datetime import datetime, timedelta

# ========================
# Page Config & RTL CSS
# ========================

st.set_page_config(page_title="×›×œ×™ ×”×©×§×¢×•×ª ××§×¦×•×¢×™", layout="wide")

RTL_CSS = """
<style>
    .stApp, .block-container {
        direction: rtl;
        text-align: right;
    }
    input, textarea, .stSelectbox, .stMultiSelect, .stNumberInput {
        direction: ltr;
        text-align: left;
    }
    [data-testid="stMetric"] {
        direction: ltr;
        text-align: center;
    }
    .stRadio > div {
        flex-direction: row-reverse;
        gap: 1rem;
    }
    .js-plotly-plot .plotly .modebar {
        direction: ltr;
    }
    .stTabs [data-baseweb="tab-list"] {
        direction: rtl;
    }
    /* Portfolio card */
    .portfolio-frame {
        border: 2px solid #3a3a4a;
        border-radius: 14px;
        padding: 1.2rem 1rem 0.8rem 1rem;
        background: rgba(30,30,46,0.55);
        margin-bottom: 0.5rem;
    }
    /* Result summary cards */
    .result-card {
        border: 1px solid #3a3a4a;
        border-radius: 10px;
        padding: 1rem;
        background: rgba(30,30,46,0.5);
        text-align: center;
        margin-top: 0.3rem;
    }
    /* Bottom-line comparison container */
    .comparison-box {
        border: 2px solid #4dabf7;
        border-radius: 14px;
        padding: 1.4rem 1.2rem;
        background: linear-gradient(135deg, rgba(77,171,247,0.08) 0%, rgba(30,30,46,0.6) 100%);
        margin-top: 1.2rem;
        margin-bottom: 0.8rem;
    }
    .comparison-box h3 {
        text-align: center;
        margin-bottom: 0.8rem;
    }
    /* Recommendation section */
    .reco-section-title {
        text-align: center;
        padding: 0.8rem 0;
    }
    .reco-badge {
        display: inline-block;
        padding: 0.2rem 0.7rem;
        border-radius: 20px;
        font-size: 0.78rem;
        font-weight: 600;
        margin-left: 0.4rem;
    }
    .badge-green { background: rgba(0,212,170,0.18); color: #00d4aa; }
    .badge-yellow { background: rgba(255,204,0,0.18); color: #ffcc00; }
    .badge-red { background: rgba(255,107,107,0.18); color: #ff6b6b; }
    .badge-blue { background: rgba(77,171,247,0.18); color: #4dabf7; }
    .reco-summary-line {
        font-size: 1.05rem;
        line-height: 1.7;
        padding: 0.15rem 0;
    }
    .reco-detail {
        font-size: 0.93rem;
        color: #b0b0c0;
        line-height: 1.6;
        padding: 0.3rem 0;
    }
    .general-tip {
        border: 1px solid #3a3a4a;
        border-radius: 10px;
        padding: 0.9rem 1.1rem;
        background: rgba(30,30,46,0.45);
        margin-top: 0.4rem;
        margin-bottom: 0.3rem;
        font-size: 0.92rem;
        line-height: 1.65;
    }
</style>
"""
st.markdown(RTL_CSS, unsafe_allow_html=True)

# ========================
# Session State Init
# ========================

if "num_portfolios" not in st.session_state:
    st.session_state.num_portfolios = 1

if "portfolios" not in st.session_state:
    st.session_state.portfolios = {}
    for i in range(3):
        st.session_state.portfolios[i] = {
            "assets": ["SPY"] if i == 0 else [],
            "weights": {"SPY": 100.0} if i == 0 else {},
            "phase": "×©×œ×‘ ×”×¦×‘×™×¨×”",
            "monthly": 0,
            "withdrawal_rate": 0.0,
            "withdrawal_month": 1,
        }

# ========================
# Comprehensive Ticker Database
# ========================

TICKER_DB = {
    # US Large Cap
    "AAPL": "Apple Inc.", "MSFT": "Microsoft Corp.",
    "GOOGL": "Alphabet (Google) Class A", "GOOG": "Alphabet (Google) Class C",
    "AMZN": "Amazon.com Inc.", "NVDA": "NVIDIA Corp.",
    "META": "Meta Platforms (Facebook)", "TSLA": "Tesla Inc.",
    "BRK-B": "Berkshire Hathaway B", "JPM": "JPMorgan Chase",
    "V": "Visa Inc.", "JNJ": "Johnson & Johnson",
    "WMT": "Walmart Inc.", "PG": "Procter & Gamble",
    "MA": "Mastercard Inc.", "UNH": "UnitedHealth Group",
    "HD": "Home Depot", "DIS": "Walt Disney Co.",
    "PYPL": "PayPal Holdings", "NFLX": "Netflix Inc.",
    "ADBE": "Adobe Inc.", "CRM": "Salesforce Inc.",
    "INTC": "Intel Corp.", "AMD": "Advanced Micro Devices",
    "CSCO": "Cisco Systems", "PEP": "PepsiCo Inc.",
    "KO": "Coca-Cola Co.", "ABT": "Abbott Laboratories",
    "MRK": "Merck & Co.", "NKE": "Nike Inc.",
    "T": "AT&T Inc.", "VZ": "Verizon Communications",
    "XOM": "Exxon Mobil Corp.", "CVX": "Chevron Corp.",
    "BA": "Boeing Co.", "CAT": "Caterpillar Inc.",
    "GS": "Goldman Sachs", "MS": "Morgan Stanley",
    "COST": "Costco Wholesale", "AVGO": "Broadcom Inc.",
    "QCOM": "Qualcomm Inc.", "TXN": "Texas Instruments",
    "NOW": "ServiceNow Inc.", "UBER": "Uber Technologies",
    "SQ": "Block Inc. (Square)", "SHOP": "Shopify Inc.",
    "SNOW": "Snowflake Inc.", "PLTR": "Palantir Technologies",
    "COIN": "Coinbase Global", "SOFI": "SoFi Technologies",
    "RIVN": "Rivian Automotive", "LCID": "Lucid Group",
    # ETFs - US Broad Market
    "SPY": "SPDR S&P 500 ETF", "VOO": "Vanguard S&P 500 ETF",
    "IVV": "iShares Core S&P 500 ETF", "QQQ": "Invesco Nasdaq 100 ETF",
    "VTI": "Vanguard Total US Market ETF", "IWM": "iShares Russell 2000 ETF",
    "DIA": "SPDR Dow Jones Industrial ETF", "VUG": "Vanguard Growth ETF",
    "VTV": "Vanguard Value ETF", "SCHD": "Schwab US Dividend Equity ETF",
    "VIG": "Vanguard Dividend Appreciation ETF",
    "ARKK": "ARK Innovation ETF", "ARKW": "ARK Next Gen Internet ETF",
    "XLK": "Technology Select Sector SPDR", "XLF": "Financial Select Sector SPDR",
    "XLE": "Energy Select Sector SPDR", "XLV": "Health Care Select Sector SPDR",
    "XLY": "Consumer Discretionary SPDR", "XLP": "Consumer Staples SPDR",
    "XLI": "Industrial Select Sector SPDR", "XLRE": "Real Estate Select Sector SPDR",
    # ETFs - International
    "VXUS": "Vanguard Total International Stock ETF",
    "EFA": "iShares MSCI EAFE ETF", "EEM": "iShares MSCI Emerging Markets ETF",
    "VWO": "Vanguard FTSE Emerging Markets ETF",
    "VEA": "Vanguard FTSE Developed Markets ETF",
    "IEMG": "iShares Core MSCI Emerging Markets ETF",
    "FXI": "iShares China Large-Cap ETF", "EWJ": "iShares MSCI Japan ETF",
    "EWG": "iShares MSCI Germany ETF", "EWU": "iShares MSCI United Kingdom ETF",
    # ETFs - Bonds
    "BND": "Vanguard Total Bond Market ETF",
    "AGG": "iShares Core US Aggregate Bond ETF",
    "TLT": "iShares 20+ Year Treasury Bond ETF",
    "IEF": "iShares 7-10 Year Treasury Bond ETF",
    "SHY": "iShares 1-3 Year Treasury Bond ETF",
    "TIP": "iShares TIPS Bond ETF",
    "LQD": "iShares Investment Grade Corporate Bond ETF",
    "HYG": "iShares iBoxx High Yield Corporate Bond ETF",
    "BIL": "SPDR Bloomberg 1-3 Month T-Bill ETF",
    "BNDX": "Vanguard Total International Bond ETF",
    "EMB": "iShares J.P. Morgan USD EM Bond ETF",
    # ETFs - Commodities / Gold
    "GLD": "SPDR Gold Shares", "IAU": "iShares Gold Trust",
    "SLV": "iShares Silver Trust", "USO": "United States Oil Fund",
    "DBC": "Invesco DB Commodity Index ETF",
    # ETFs - Real Estate
    "VNQ": "Vanguard Real Estate ETF", "IYR": "iShares US Real Estate ETF",
    "VNQI": "Vanguard Global ex-US Real Estate ETF",
    # Israeli Stocks
    "NICE": "NICE Ltd.", "CYBR": "CyberArk Software",
    "CHKP": "Check Point Software", "WIX": "Wix.com Ltd.",
    "MNDY": "monday.com Ltd.", "GLBE": "Global-e Online",
    "FVRR": "Fiverr International", "RSKD": "Riskified Ltd.",
    # Crypto-related
    "BTC-USD": "Bitcoin USD", "ETH-USD": "Ethereum USD",
    "MSTR": "MicroStrategy (Bitcoin proxy)",
    "BITO": "ProShares Bitcoin Strategy ETF",
    "IBIT": "iShares Bitcoin Trust ETF",
}

PERIOD_MAP = {
    "×™×•×": "1d", "×©×‘×•×¢": "5d", "×—×•×“×©": "1mo",
    "××ª×—×™×œ×ª ×”×©× ×”": "ytd", "×©× ×”": "1y", "5 ×©× ×™×": "5y",
}

MONTHS_HEB = {
    1: "×™× ×•××¨", 2: "×¤×‘×¨×•××¨", 3: "××¨×¡", 4: "××¤×¨×™×œ",
    5: "×××™", 6: "×™×•× ×™", 7: "×™×•×œ×™", 8: "××•×’×•×¡×˜",
    9: "×¡×¤×˜××‘×¨", 10: "××•×§×˜×•×‘×¨", 11: "× ×•×‘××‘×¨", 12: "×“×¦××‘×¨",
}


def search_tickers(query: str, limit: int = 12) -> list[tuple[str, str]]:
    """Fast local search across TICKER_DB by symbol or name."""
    if not query:
        return []
    q = query.upper().strip()
    exact, starts, contains = [], [], []
    for sym, name in TICKER_DB.items():
        sym_up, name_up = sym.upper(), name.upper()
        if sym_up == q:
            exact.append((sym, name))
        elif sym_up.startswith(q) or name_up.startswith(q):
            starts.append((sym, name))
        elif q in sym_up or q in name_up:
            contains.append((sym, name))
    return (exact + starts + contains)[:limit]


# ========================
# Data Functions
# ========================


@st.cache_data(ttl=3600, show_spinner=False)
def fetch_price_history(ticker: str, period: str) -> pd.DataFrame:
    """Download price history via yfinance (for search tool)."""
    try:
        tk = yf.Ticker(ticker)
        interval = "5m" if period == "1d" else ("60m" if period == "5d" else "1d")
        df = tk.history(period=period, interval=interval, auto_adjust=True)
        if df.empty:
            return pd.DataFrame()
        return df[["Close"]]
    except Exception:
        return pd.DataFrame()


@st.cache_data(ttl=3600, show_spinner=False)
def download_close_prices(tickers: tuple, start_date: str, end_date: str) -> pd.DataFrame:
    """Download daily close prices for date range."""
    try:
        data = yf.download(
            list(tickers), start=start_date, end=end_date,
            auto_adjust=True, progress=False,
        )
        if data.empty:
            return pd.DataFrame()
        if len(tickers) == 1:
            closes = data[["Close"]]
            closes.columns = [tickers[0]]
        else:
            closes = data["Close"]
        return closes
    except Exception:
        return pd.DataFrame()


@st.cache_data(ttl=86400, show_spinner=False)
def get_usd_to_ils() -> float:
    """Get current USD/ILS exchange rate."""
    try:
        tk = yf.Ticker("USDILS=X")
        data = tk.history(period="5d")
        if not data.empty:
            return float(data["Close"].iloc[-1])
    except Exception:
        pass
    return 3.6


def format_currency(value: float, cur: str) -> str:
    if cur == "ILS":
        return f"â‚ª{value:,.0f}"
    return f"${value:,.0f}"


# ================================================================
#   PART 1  â€“  ×›×œ×™ × ×™×ª×•×— ×× ×™×•×ª  (Stock Research Tool)
# ================================================================

st.markdown("# ğŸ“Š ×›×œ×™ ×”×©×§×¢×•×ª ××§×¦×•×¢×™")

st.markdown("---")
st.markdown("## ğŸ” ×—×œ×§ ××³ â€” ×›×œ×™ × ×™×ª×•×— ×× ×™×•×ª")

search_col1, search_col2 = st.columns([3, 1])

with search_col1:
    search_query = st.text_input(
        "×”×§×œ×“ ×¡×™××•×œ ××• ×©× ×—×‘×¨×”",
        placeholder="×œ××©×œ: AAPL, Tesla, Gold, QQQ â€¦",
        key="global_search",
    )

with search_col2:
    search_period = st.radio(
        "×ª×§×•×¤×”",
        list(PERIOD_MAP.keys()),
        index=4,
        horizontal=True,
        key="search_period",
    )

if search_query:
    matches = search_tickers(search_query)
    if matches:
        options_list = [f"{sym}  â€”  {name}" for sym, name in matches]
        chosen = st.selectbox("×ª×•×¦××•×ª ×ª×•×××•×ª â€” ×‘×—×¨ × ×›×¡:", options=options_list, key="search_select")
        chosen_ticker = chosen.split("  â€”  ")[0].strip() if chosen else None
    else:
        chosen_ticker = search_query.strip().upper()
        st.info(f"×œ× × ××¦× ×‘×××’×¨ â€” ×× ×¡×” ×œ×˜×¢×•×Ÿ: {chosen_ticker}")

    if chosen_ticker:
        with st.spinner("×˜×•×¢×Ÿ × ×ª×•× ×™×..."):
            price_data = fetch_price_history(chosen_ticker, PERIOD_MAP[search_period])

        if not price_data.empty:
            try:
                asset_name = yf.Ticker(chosen_ticker).info.get("shortName", chosen_ticker)
            except Exception:
                asset_name = chosen_ticker

            st.markdown(f"#### {asset_name} ({chosen_ticker})")

            fig_s = go.Figure()
            fig_s.add_trace(go.Scatter(
                x=price_data.index, y=price_data["Close"],
                mode="lines", name=chosen_ticker,
                line=dict(color="#00d4aa", width=2),
                fill="tozeroy", fillcolor="rgba(0,212,170,0.1)",
            ))
            fig_s.update_layout(
                template="plotly_dark", height=400,
                margin=dict(l=20, r=20, t=30, b=20),
                xaxis_title="×ª××¨×™×š", yaxis_title="××—×™×¨ ($)",
                hovermode="x unified",
            )
            st.plotly_chart(fig_s, use_container_width=True)

            fp = float(price_data["Close"].iloc[0])
            lp = float(price_data["Close"].iloc[-1])
            ch = ((lp - fp) / fp) * 100
            hi = float(price_data["Close"].max())
            lo = float(price_data["Close"].min())

            mc1, mc2, mc3, mc4 = st.columns(4)
            mc1.metric("××—×™×¨ × ×•×›×—×™", f"${lp:.2f}")
            mc2.metric("×©×™× ×•×™ ×‘×ª×§×•×¤×”", f"{ch:+.2f}%")
            mc3.metric("×©×™×", f"${hi:.2f}")
            mc4.metric("×©×¤×œ", f"${lo:.2f}")
        else:
            st.warning(f"×œ× × ××¦××• × ×ª×•× ×™× ×¢×‘×•×¨: {chosen_ticker}")


# ================================================================
#   PART 2  â€“  ×”×’×“×¨×ª ×”×©×§×¢×” + ×¤×•×¨×˜×¤×•×œ×™×• + ×¡×™××•×œ×¦×™×”
# ================================================================

st.markdown("---")
st.markdown("## ğŸ’° ×—×œ×§ ×‘×³ â€” ×¡×™××•×œ×¦×™×™×ª ×ª×™×§×™ ×”×©×§×¢×•×ª")

# ---- Global investment parameters ----
st.markdown("### âš™ï¸ ×”×’×“×¨×•×ª ×”×©×§×¢×” ×›×œ×œ×™×•×ª")

g1, g2, g3, g4 = st.columns(4)

with g1:
    initial_capital = st.number_input(
        "ğŸ’µ ×¡×›×•× ×”×©×§×¢×” ×¨××©×•× ×™ (×—×“-×¤×¢××™)",
        min_value=0, max_value=100_000_000,
        value=100_000, step=10_000,
        key="initial_capital",
    )

with g2:
    global_monthly = st.number_input(
        "ğŸ“† ×”×¤×§×“×” ×—×•×“×©×™×ª ×§×‘×•×¢×”",
        min_value=0, max_value=1_000_000,
        value=0, step=500,
        key="global_monthly",
    )

with g3:
    currency = st.radio(
        "ğŸ’± ××˜×‘×¢ ×ª×¦×•×’×”",
        ["USD ($)", "ILS (â‚ª)"],
        horizontal=True, key="currency_toggle",
    )
    active_currency = "ILS" if "ILS" in currency else "USD"

with g4:
    rebalance_freq = st.selectbox(
        "ğŸ”„ ××™×–×•×Ÿ ××—×“×©",
        ["×œ×œ×", "×—×•×“×©×™", "×¨×‘×¢×•× ×™", "×©× ×ª×™"],
        key="rebalance_freq",
    )

# ---- Tax setting ----
tax_col, _, _ = st.columns([1, 1, 2])
with tax_col:
    capital_gains_tax_pct = st.number_input(
        "ğŸ›ï¸ ××¡ ×¨×•×•×—×™ ×”×•×Ÿ (%)",
        min_value=0.0, max_value=50.0,
        value=25.0, step=0.5,
        key="cg_tax_pct",
        help="××—×•×– ×”××¡ ×¢×œ ×¨×•×•×—×™ ×”×•×Ÿ. ×‘×¨×™×¨×ª ××—×“×œ: 25% (×™×©×¨××œ). × ×™×ª×Ÿ ×œ×©× ×•×ª.",
    )
CAPITAL_GAINS_TAX = capital_gains_tax_pct / 100.0

freq_map = {"×œ×œ×": None, "×—×•×“×©×™": "ME", "×¨×‘×¢×•× ×™": "QE", "×©× ×ª×™": "YE"}
exchange_rate = get_usd_to_ils() if active_currency == "ILS" else 1.0

# ---- Date range ----
st.markdown("### ğŸ“… ×˜×•×•×— ×–××Ÿ")
st.caption("×‘×—×¨ ×©× ×ª ×”×ª×—×œ×” ×•×©× ×ª ×¡×™×•×. ×× ×©× ×ª ×”×¡×™×•× ×‘×¢×ª×™×“ â€” ×”×¡×™××•×œ×¦×™×” ×ª×‘×¦×¢ ×”×¢×¨×›×” (projection) ×¢×œ ×‘×¡×™×¡ ×ª×©×•××•×ª ×”×™×¡×˜×•×¨×™×•×ª.")

current_year = datetime.today().year
dr1, dr2 = st.columns(2)
with dr1:
    start_year = st.number_input(
        "ğŸ“† ××©× ×ª", min_value=1990, max_value=current_year + 20,
        value=current_year - 10, step=1, key="start_year",
    )
with dr2:
    end_year = st.number_input(
        "ğŸ“† ×¢×“ ×©× ×ª", min_value=int(start_year) + 1, max_value=current_year + 30,
        value=max(int(start_year) + 10, current_year), step=1, key="end_year",
    )

is_future = int(end_year) > current_year
total_sim_years = int(end_year) - int(start_year)

if is_future:
    st.info(
        f"â³ ×˜×•×•×— ×”×¡×™××•×œ×¦×™×” ×›×•×œ×œ ×©× ×™× ×¢×ª×™×“×™×•×ª ({current_year + 1}â€“{int(end_year)}). "
        f"×”×¤×¨×•×™×§×¦×™×” ××‘×•×¡×¡×ª ×¢×œ ×ª×©×•××•×ª ×”×™×¡×˜×•×¨×™×•×ª ×××•×¦×¢×•×ª â€” ××™× ×” ××‘×˜×™×—×” ×ª×©×•××” ×¢×ª×™×“×™×ª."
    )

# ================================================================
#   Portfolio management â€“ add / remove (max 3)
# ================================================================

st.markdown("---")
st.markdown("### ğŸ“ ×”×’×“×¨×ª ×¤×•×¨×˜×¤×•×œ×™×• ×œ×”×©×•×•××”")

add_col, remove_col, info_col = st.columns([1, 1, 2])
with add_col:
    if st.button("â• ×”×•×¡×£ ×¤×•×¨×˜×¤×•×œ×™×•", disabled=(st.session_state.num_portfolios >= 3)):
        st.session_state.num_portfolios += 1
        new_idx = st.session_state.num_portfolios - 1
        if new_idx not in st.session_state.portfolios:
            st.session_state.portfolios[new_idx] = {
                "assets": [], "weights": {},
                "phase": "×©×œ×‘ ×”×¦×‘×™×¨×”", "monthly": 0,
                "withdrawal_rate": 0.0,
                "withdrawal_month": 1,
            }
        st.rerun()

with remove_col:
    if st.button("â– ×”×¡×¨ ×¤×•×¨×˜×¤×•×œ×™×•", disabled=(st.session_state.num_portfolios <= 1)):
        st.session_state.num_portfolios -= 1
        st.rerun()

with info_col:
    st.caption(f"××•×¦×’×™× {st.session_state.num_portfolios} ××ª×•×š 3 ×¤×•×¨×˜×¤×•×œ×™×• ××§×¡×™××•×")


ASSET_OPTIONS = sorted(TICKER_DB.keys())
num_p = st.session_state.num_portfolios
portfolio_cols = st.columns(num_p)


def render_portfolio(col, idx):
    """Render one portfolio card."""
    with col:
        st.markdown('<div class="portfolio-frame">', unsafe_allow_html=True)
        st.markdown(f"#### ğŸ“Œ ×¤×•×¨×˜×¤×•×œ×™×• {idx + 1}")

        # --- Phase ---
        phase = st.radio(
            "×©×œ×‘", ["×©×œ×‘ ×”×¦×‘×™×¨×”", "×©×œ×‘ ×”××©×™×›×” / ×¤×¨×™×©×”"],
            key=f"phase_{idx}", horizontal=True,
        )

        # --- Withdrawal (independent, only in withdrawal phase) ---
        withdrawal_rate = 0.0
        withdrawal_month = 1
        if "××©×™×›×”" in phase or "×¤×¨×™×©×”" in phase:
            withdrawal_rate = st.number_input(
                "ğŸ“¤ ××—×•×– ××©×™×›×” ×©× ×ª×™ (%)",
                min_value=0.0, max_value=20.0, value=4.0, step=0.5,
                key=f"wd_{idx}",
                help="×”×›×¡×£ ×™××©×š ××ª×•×š ×”×ª×™×§ ×¤×¢× ×‘×©× ×” ×‘×—×•×“×© ×©×ª×‘×—×¨. ×–×” ×œ× ××©×¤×™×¢ ×¢×œ ×”×”×©×§×¢×” ×”×¨××©×•× ×™×ª ×•×”×”×¤×§×“×” ×”×—×•×“×©×™×ª.",
            )
            withdrawal_month = st.selectbox(
                "ğŸ“… ×—×•×“×© ××©×™×›×”",
                options=list(MONTHS_HEB.keys()),
                format_func=lambda m: f"{MONTHS_HEB[m]} ({m})",
                index=0,
                key=f"wd_month_{idx}",
                help=f"×‘××™×–×” ×—×•×“×© ×‘×©× ×” ×ª×ª×‘×¦×¢ ×”××©×™×›×” ×”×©× ×ª×™×ª ({capital_gains_tax_pct:.0f}% ××¡ ×¨×•×•×—×™ ×”×•×Ÿ ×™× ×•×›×” ××”×¨×•×•×—).",
            )
            st.caption(f"ğŸ’° {capital_gains_tax_pct:.0f}% ××¡ ×¨×•×•×—×™ ×”×•×Ÿ ×™× ×•×›×” ××•×˜×•××˜×™×ª ××—×œ×§ ×”×¨×•×•×— ×‘××©×™×›×”")

        # --- Asset selection ---
        selected_assets = st.multiselect(
            "ğŸ” ×‘×—×¨ × ×›×¡×™× / ×× ×™×•×ª",
            options=ASSET_OPTIONS,
            default=st.session_state.portfolios[idx].get("assets", []),
            key=f"assets_{idx}",
            format_func=lambda x: f"{x} â€” {TICKER_DB.get(x, '')}",
        )

        custom_ticker = st.text_input(
            "â• ×”×•×¡×£ ×¡×™××•×œ ×™×“× ×™×ª (××•×¤×¨×“ ×‘×¤×¡×™×§)",
            placeholder="SOXX, KWEB â€¦",
            key=f"custom_{idx}",
        )
        if custom_ticker:
            for part in custom_ticker.split(","):
                ct = part.strip().upper()
                if ct and ct not in selected_assets:
                    selected_assets.append(ct)

        # --- Weights ---
        weights = {}
        if selected_assets:
            st.markdown("**âš–ï¸ ×”×§×¦××ª ××—×•×–×™× (%)**")
            default_w = round(100.0 / len(selected_assets), 1)
            for asset in selected_assets:
                prev = st.session_state.portfolios[idx].get("weights", {}).get(asset, default_w)
                w = st.number_input(
                    f"{asset}", min_value=0.0, max_value=100.0,
                    value=min(prev, 100.0), step=5.0,
                    key=f"w_{idx}_{asset}",
                )
                weights[asset] = w

            total_w = sum(weights.values())
            if abs(total_w - 100.0) < 0.01:
                st.success(f"âœ… ×¡×”×´×›: {total_w:.1f}%")
            elif total_w > 100:
                st.error(f"ğŸš« ×¡×”×´×›: {total_w:.1f}% â€” ×—×¨×’×ª!")
            else:
                st.warning(f"âš ï¸ ×¡×”×´×›: {total_w:.1f}% (×¦×¨×™×š 100%)")
        else:
            st.info("×‘×—×¨ ×œ×¤×—×•×ª × ×›×¡ ××—×“")

        st.markdown("</div>", unsafe_allow_html=True)

        st.session_state.portfolios[idx] = {
            "assets": selected_assets,
            "weights": weights,
            "phase": phase,
            "monthly": 0,  # stored per-portfolio but we use global
            "withdrawal_rate": withdrawal_rate,
            "withdrawal_month": withdrawal_month,
        }


for idx in range(num_p):
    render_portfolio(portfolio_cols[idx], idx)


# ================================================================
#   Simulation Engine
# ================================================================


def simulate_portfolio(port_cfg, initial, monthly_contribution, start_y, end_y, rebalance):
    """
    Simulate portfolio value from start_year to end_year.
    - If entirely in the past: use historical data.
    - If partly/fully in the future: use historical data where available,
      then project forward using average historical daily returns.
    - Tracks cost_basis for capital gains tax on withdrawals.
    - Withdrawal happens once a year in the chosen month.
    Returns (pd.Series of value, dict of summary stats).
    """
    assets = port_cfg["assets"]
    weights_dict = port_cfg["weights"]
    withdrawal_rate = port_cfg.get("withdrawal_rate", 0.0)
    withdrawal_month = port_cfg.get("withdrawal_month", 1)

    if not assets or not weights_dict:
        return pd.Series(dtype=float), {}

    total_w = sum(weights_dict.values())
    if total_w == 0:
        return pd.Series(dtype=float), {}

    norm_weights = np.array([weights_dict.get(a, 0) / total_w for a in assets])

    today = datetime.today()
    sim_start = datetime(int(start_y), 1, 1)
    sim_end = datetime(int(end_y), 12, 31)

    # --- Download all available historical data ---
    hist_end = min(sim_end, today)
    # We need some history even for pure-future projections (to estimate returns)
    dl_start = sim_start if sim_start < today else today - timedelta(days=10 * 365)
    dl_end = hist_end

    closes = download_close_prices(
        tuple(assets),
        dl_start.strftime("%Y-%m-%d"),
        dl_end.strftime("%Y-%m-%d"),
    )
    if closes.empty:
        return pd.Series(dtype=float), {}

    missing = [a for a in assets if a not in closes.columns]
    if missing:
        return pd.Series(dtype=float), {}

    closes = closes[list(assets)]
    returns_df = closes.pct_change().dropna()

    if returns_df.empty:
        return pd.Series(dtype=float), {}

    port_daily_returns = (returns_df * norm_weights).sum(axis=1)

    # --- Build the historical portion of the simulation ---
    # Trim to sim range
    hist_returns = port_daily_returns[port_daily_returns.index >= pd.Timestamp(sim_start)]

    # --- If we need future projection ---
    if sim_end > today:
        # Compute stats from available history
        mean_daily = port_daily_returns.mean()
        std_daily = port_daily_returns.std()

        # Generate future trading days (~252/year)
        future_start = today + timedelta(days=1)
        future_days = pd.bdate_range(start=future_start, end=sim_end)
        np.random.seed(42)  # reproducible
        future_returns = np.random.normal(mean_daily, std_daily, len(future_days))
        future_series = pd.Series(future_returns, index=future_days)

        # Combine
        combined_returns = pd.concat([hist_returns, future_series])
    else:
        combined_returns = hist_returns

    if rebalance:
        combined_returns = combined_returns.resample(rebalance).apply(
            lambda x: (1 + x).prod() - 1
        )

    # --- Walk through and build value series (with tax engine) ---
    capital = float(initial)
    cost_basis = float(initial)  # tracks total cost basis for tax calculation
    total_invested = float(initial)
    total_withdrawn_gross = 0.0
    total_tax_paid = 0.0
    total_withdrawn_net = 0.0
    values = []
    prev_month = None
    withdrew_this_year = set()  # track which years we already withdrew in

    for date, r in combined_returns.items():
        cur_month = (date.year, date.month)
        new_month = prev_month is not None and cur_month != prev_month
        prev_month = cur_month

        capital *= (1 + r)

        if new_month:
            # Monthly contribution (always applied regardless of phase)
            if monthly_contribution > 0:
                capital += monthly_contribution
                cost_basis += monthly_contribution
                total_invested += monthly_contribution

            # Annual withdrawal with capital gains tax â€” only in the chosen month
            if withdrawal_rate > 0 and date.month == withdrawal_month and date.year not in withdrew_this_year:
                withdrew_this_year.add(date.year)
                # Calculate gross annual withdrawal
                annual_wd = capital * (withdrawal_rate / 100.0)
                gross_wd = annual_wd

                # Calculate capital gains tax on profit portion only
                if capital > 0 and capital > cost_basis:
                    gain_ratio = (capital - cost_basis) / capital
                    taxable_amount = gross_wd * gain_ratio
                    tax = taxable_amount * CAPITAL_GAINS_TAX
                else:
                    tax = 0.0

                net_wd = gross_wd - tax

                # Update tracking
                total_withdrawn_gross += gross_wd
                total_tax_paid += tax
                total_withdrawn_net += net_wd

                # Deduct full gross from portfolio (tax is taken from the withdrawal)
                capital -= gross_wd
                capital = max(capital, 0)

                # Update cost basis proportionally
                if capital > 0:
                    ratio_remaining = capital / (capital + gross_wd) if (capital + gross_wd) > 0 else 0
                    cost_basis *= ratio_remaining
                else:
                    cost_basis = 0

        values.append(capital)

    if not values:
        return pd.Series(dtype=float), {}

    series = pd.Series(values, index=combined_returns.index)

    # --- Compute summary ---
    start_val = float(initial)
    end_val = series.iloc[-1]
    n_years = max((series.index[-1] - series.index[0]).days / 365.25, 0.01)
    total_return_pct = ((end_val / start_val) - 1) * 100 if start_val > 0 else 0
    cagr = ((end_val / start_val) ** (1 / n_years) - 1) * 100 if start_val > 0 else 0
    daily_ret = series.pct_change().dropna()
    ann_vol = daily_ret.std() * np.sqrt(252) * 100
    sharpe = (daily_ret.mean() / daily_ret.std() * np.sqrt(252)) if daily_ret.std() > 0 else 0
    cumulative = (1 + daily_ret).cumprod()
    peak = cumulative.cummax()
    max_dd = ((cumulative - peak) / peak).min() * 100 if len(cumulative) > 0 else 0

    stats = {
        "start_val": start_val,
        "end_val": end_val,
        "total_invested": total_invested,
        "cost_basis": cost_basis,
        "total_return_pct": total_return_pct,
        "cagr": cagr,
        "ann_vol": ann_vol,
        "sharpe": sharpe,
        "max_dd": max_dd,
        "n_years": n_years,
        "total_withdrawn_gross": total_withdrawn_gross,
        "total_tax_paid": total_tax_paid,
        "total_withdrawn_net": total_withdrawn_net,
    }

    return series, stats


# ================================================================
#   Recommendation Engine
# ================================================================


def render_recommendations(all_stats: list, portfolios_cfg: dict, initial: float, monthly: float):
    """Render beautiful expandable recommendation cards for each portfolio."""
    if not all_stats:
        return

    st.markdown("---")
    st.markdown('<div class="reco-section-title">', unsafe_allow_html=True)
    st.markdown("### \U0001f4a1 \u05d4\u05de\u05dc\u05e6\u05d5\u05ea \u05de\u05e7\u05e6\u05d5\u05e2\u05d9\u05d5\u05ea")
    st.markdown('</div>', unsafe_allow_html=True)

    # ---- Comparative winner badges (if >1 portfolio) ----
    if len(all_stats) > 1:
        best_sharpe = max(range(len(all_stats)), key=lambda i: all_stats[i]["sharpe"])
        best_return = max(range(len(all_stats)), key=lambda i: all_stats[i]["total_return_pct"])
        lowest_vol = min(range(len(all_stats)), key=lambda i: all_stats[i]["ann_vol"])

        trophy_cols = st.columns(3)
        with trophy_cols[0]:
            st.markdown(
                f'<div class="general-tip" style="text-align:center;">'
                f'\U0001f3c6 <b>\u05e9\u05d0\u05e8\u05e4 \u05d4\u05d8\u05d5\u05d1 \u05d1\u05d9\u05d5\u05ea\u05e8</b><br>'
                f'\u05e4\u05d5\u05e8\u05d8\u05e4\u05d5\u05dc\u05d9\u05d5 {best_sharpe + 1} &nbsp;'
                f'<span class="reco-badge badge-green">{all_stats[best_sharpe]["sharpe"]:.2f}</span></div>',
                unsafe_allow_html=True,
            )
        with trophy_cols[1]:
            st.markdown(
                f'<div class="general-tip" style="text-align:center;">'
                f'\U0001f4c8 <b>\u05ea\u05e9\u05d5\u05d0\u05d4 \u05d2\u05d1\u05d5\u05d4\u05d4 \u05d1\u05d9\u05d5\u05ea\u05e8</b><br>'
                f'\u05e4\u05d5\u05e8\u05d8\u05e4\u05d5\u05dc\u05d9\u05d5 {best_return + 1} &nbsp;'
                f'<span class="reco-badge badge-blue">{all_stats[best_return]["total_return_pct"]:.1f}%</span></div>',
                unsafe_allow_html=True,
            )
        with trophy_cols[2]:
            st.markdown(
                f'<div class="general-tip" style="text-align:center;">'
                f'\U0001f6e1\ufe0f <b>\u05e1\u05d9\u05db\u05d5\u05df \u05e0\u05de\u05d5\u05da \u05d1\u05d9\u05d5\u05ea\u05e8</b><br>'
                f'\u05e4\u05d5\u05e8\u05d8\u05e4\u05d5\u05dc\u05d9\u05d5 {lowest_vol + 1} &nbsp;'
                f'<span class="reco-badge badge-yellow">{all_stats[lowest_vol]["ann_vol"]:.1f}%</span></div>',
                unsafe_allow_html=True,
            )
        st.markdown("")

    # ---- Per-portfolio expandable cards ----
    for i, stats in enumerate(all_stats):
        pcfg = portfolios_cfg[i]
        n_assets = len(pcfg["assets"])
        phase = pcfg["phase"]
        sharpe = stats["sharpe"]
        vol = stats["ann_vol"]
        dd = stats["max_dd"]
        is_wd = "\u05de\u05e9\u05d9\u05db\u05d4" in phase or "\u05e4\u05e8\u05d9\u05e9\u05d4" in phase

        # --- Build summary line (always visible) ---
        # Diversification badge
        if n_assets == 1:
            div_badge = '<span class="reco-badge badge-red">\u05e4\u05d9\u05d6\u05d5\u05e8 \u05e0\u05de\u05d5\u05da</span>'
        elif n_assets <= 3:
            div_badge = '<span class="reco-badge badge-yellow">\u05e4\u05d9\u05d6\u05d5\u05e8 \u05d1\u05d9\u05e0\u05d5\u05e0\u05d9</span>'
        else:
            div_badge = '<span class="reco-badge badge-green">\u05e4\u05d9\u05d6\u05d5\u05e8 \u05d8\u05d5\u05d1</span>'

        # Sharpe badge
        if sharpe > 0.8:
            sharpe_badge = '<span class="reco-badge badge-green">\u05e9\u05d0\u05e8\u05e4 \u05de\u05e6\u05d5\u05d9\u05df</span>'
        elif sharpe > 0.4:
            sharpe_badge = '<span class="reco-badge badge-yellow">\u05e9\u05d0\u05e8\u05e4 \u05e1\u05d1\u05d9\u05e8</span>'
        else:
            sharpe_badge = '<span class="reco-badge badge-red">\u05e9\u05d0\u05e8\u05e4 \u05e0\u05de\u05d5\u05da</span>'

        # Risk badge
        if vol > 25:
            risk_badge = '<span class="reco-badge badge-red">\u05e1\u05d9\u05db\u05d5\u05df \u05d2\u05d1\u05d5\u05d4</span>'
        elif vol > 15:
            risk_badge = '<span class="reco-badge badge-yellow">\u05e1\u05d9\u05db\u05d5\u05df \u05d1\u05d9\u05e0\u05d5\u05e0\u05d9</span>'
        else:
            risk_badge = '<span class="reco-badge badge-green">\u05e1\u05d9\u05db\u05d5\u05df \u05e0\u05de\u05d5\u05da</span>'

        phase_icon = "\U0001f3e6" if is_wd else "\U0001f4c8"
        phase_label = "\u05e9\u05dc\u05d1 \u05de\u05e9\u05d9\u05db\u05d4" if is_wd else "\u05e9\u05dc\u05d1 \u05e6\u05d1\u05d9\u05e8\u05d4"

        header_html = (
            f'{phase_icon} <b>\u05e4\u05d5\u05e8\u05d8\u05e4\u05d5\u05dc\u05d9\u05d5 {i+1}</b> &mdash; {phase_label}'
            f'&nbsp;&nbsp; {div_badge} {sharpe_badge} {risk_badge}'
        )

        with st.expander(f"\U0001f4cc \u05e4\u05d5\u05e8\u05d8\u05e4\u05d5\u05dc\u05d9\u05d5 {i+1} \u2014 {phase_label}  |  \u05e9\u05d0\u05e8\u05e4 {sharpe:.2f}  |  \u05ea\u05e0\u05d5\u05d3\u05ea\u05d9\u05d5\u05ea {vol:.1f}%"):
            st.markdown(header_html, unsafe_allow_html=True)
            st.markdown("")

            # --- Detail metrics in 3 columns ---
            d1, d2, d3 = st.columns(3)
            with d1:
                st.metric("\u05e9\u05d0\u05e8\u05e4", f"{sharpe:.2f}")
            with d2:
                st.metric("\u05ea\u05e0\u05d5\u05d3\u05ea\u05d9\u05d5\u05ea \u05e9\u05e0\u05ea\u05d9\u05ea", f"{vol:.1f}%")
            with d3:
                st.metric("\u05d9\u05e8\u05d9\u05d3\u05d4 \u05de\u05e7\u05e1\u05d9\u05de\u05dc\u05d9\u05ea", f"{dd:.1f}%")

            st.markdown("")

            # --- Diversification advice ---
            if n_assets == 1:
                st.warning("\u26a0\ufe0f **\u05e4\u05d9\u05d6\u05d5\u05e8 \u05e0\u05de\u05d5\u05da \u05de\u05d0\u05d5\u05d3** \u2014 \u05e0\u05db\u05e1 \u05d1\u05d5\u05d3\u05d3. \u05de\u05d5\u05de\u05dc\u05e5 \u05dc\u05d4\u05d5\u05e1\u05d9\u05e3 ETF \u05e8\u05d7\u05d1 (VTI/VXUS) \u05d5\u05d0\u05d2\u05f4\u05d7 (BND).")
            elif n_assets <= 3:
                st.info("\U0001f536 **\u05e4\u05d9\u05d6\u05d5\u05e8 \u05d1\u05d9\u05e0\u05d5\u05e0\u05d9** \u2014 \u05e9\u05e7\u05d5\u05dc \u05dc\u05d4\u05d5\u05e1\u05d9\u05e3 2-3 \u05d0\u05e4\u05d9\u05e7\u05d9\u05dd \u05e0\u05d5\u05e1\u05e4\u05d9\u05dd \u05dc\u05d4\u05e7\u05d8\u05e0\u05ea \u05e1\u05d9\u05db\u05d5\u05df.")
            else:
                st.success("\u2705 **\u05e4\u05d9\u05d6\u05d5\u05e8 \u05d8\u05d5\u05d1** \u2014 \u05de\u05d2\u05d5\u05d5\u05df \u05e0\u05db\u05e1\u05d9\u05dd \u05d1\u05ea\u05d9\u05e7.")

            # --- Risk analysis ---
            if vol > 25:
                st.markdown('<div class="reco-detail">\U0001f534 \u05ea\u05e0\u05d5\u05d3\u05ea\u05d9\u05d5\u05ea \u05d2\u05d1\u05d5\u05d4\u05d4 \u05de\u05ea\u05d0\u05d9\u05de\u05d4 \u05dc\u05de\u05e9\u05e7\u05d9\u05e2 \u05d0\u05d2\u05e8\u05e1\u05d9\u05d1\u05d9 \u05e2\u05dd \u05d0\u05d5\u05e4\u05e7 \u05d0\u05e8\u05d5\u05da. \u05d5\u05d3\u05d0 \u05e9\u05d0\u05ea\u05d4 \u05de\u05d5\u05db\u05df \u05dc\u05e1\u05d1\u05d5\u05dc \u05ea\u05e0\u05d5\u05d3\u05d5\u05ea \u05d7\u05d3\u05d5\u05ea \u05dc\u05dc\u05d0 \u05dc\u05de\u05db\u05d5\u05e8 \u05d1\u05e4\u05d0\u05e0\u05d9\u05e7\u05d4.</div>', unsafe_allow_html=True)
            elif vol > 15:
                st.markdown('<div class="reco-detail">\U0001f7e1 \u05ea\u05e0\u05d5\u05d3\u05ea\u05d9\u05d5\u05ea \u05d1\u05d9\u05e0\u05d5\u05e0\u05d9\u05ea \u2014 \u05e1\u05d9\u05db\u05d5\u05df \u05de\u05d0\u05d5\u05d6\u05df, \u05d3\u05d5\u05e8\u05e9 \u05de\u05e9\u05de\u05e2\u05ea \u05d1\u05d9\u05e8\u05d9\u05d3\u05d5\u05ea.</div>', unsafe_allow_html=True)
            else:
                st.markdown('<div class="reco-detail">\U0001f7e2 \u05ea\u05e0\u05d5\u05d3\u05ea\u05d9\u05d5\u05ea \u05e0\u05de\u05d5\u05db\u05d4 \u2014 \u05e9\u05de\u05e8\u05e0\u05d9, \u05de\u05ea\u05d0\u05d9\u05dd \u05dc\u05d9\u05e6\u05d9\u05d1\u05d5\u05ea.</div>', unsafe_allow_html=True)

            if dd < -30:
                st.markdown(f'<div class="reco-detail">\u26a0\ufe0f \u05d9\u05e8\u05d9\u05d3\u05d4 \u05de\u05e7\u05e1\u05d9\u05de\u05dc\u05d9\u05ea \u05d7\u05de\u05d5\u05e8\u05d4 ({dd:.1f}%) \u2014 \u05d5\u05d3\u05d0 \u05e9\u05ea\u05e2\u05de\u05d5\u05d3 \u05d1\u05d6\u05d4 \u05de\u05d1\u05dc\u05d9 \u05dc\u05de\u05db\u05d5\u05e8 \u05d1\u05e4\u05d0\u05e0\u05d9\u05e7\u05d4.</div>', unsafe_allow_html=True)

            st.markdown("")

            # --- Phase-specific advice ---
            if is_wd:
                st.markdown(
                    '<div class="general-tip">'
                    '\U0001f3e6 <b>\u05e9\u05dc\u05d1 \u05e4\u05e8\u05d9\u05e9\u05d4</b> \u2014 \u05d4\u05e2\u05d3\u05e3 \u05d0\u05d2\u05f4\u05d7 \u05d5\u05d3\u05d9\u05d1\u05d9\u05d3\u05e0\u05d3\u05d9\u05dd. '
                    '3-4% \u05de\u05e9\u05d9\u05db\u05d4 \u05e9\u05e0\u05ea\u05d9\u05ea \u05e0\u05d7\u05e9\u05d1\u05ea \u05d1\u05ea-\u05e7\u05d9\u05d9\u05de\u05d0.'
                    '</div>',
                    unsafe_allow_html=True,
                )
                wd_rate = pcfg.get("withdrawal_rate", 0)
                if wd_rate > 5:
                    st.error(f"\u26a0\ufe0f \u05de\u05e9\u05d9\u05db\u05d4 \u05e9\u05dc {wd_rate}% \u05d2\u05d1\u05d5\u05d4\u05d4 \u2014 \u05e1\u05d9\u05db\u05d5\u05df \u05dc\u05de\u05d9\u05e6\u05d5\u05d9 \u05d4\u05e7\u05e8\u05df. \u05e9\u05e7\u05d5\u05dc 3.5-4%.")

                # Tax insight
                tax_paid = stats.get("total_tax_paid", 0)
                total_wd_gross = stats.get("total_withdrawn_gross", 0)
                if tax_paid > 0 and total_wd_gross > 0:
                    tax_ratio = tax_paid / total_wd_gross * 100
                    st.markdown(
                        f'<div class="general-tip">'
                        f'\U0001f3db\ufe0f <b>\u05de\u05d9\u05e1\u05d5\u05d9</b>: \u05e9\u05d5\u05dc\u05dd {tax_ratio:.1f}% \u05de\u05e1 \u05d0\u05e4\u05e7\u05d8\u05d9\u05d1\u05d9 \u05e2\u05dc \u05d4\u05de\u05e9\u05d9\u05db\u05d5\u05ea '
                        f'({capital_gains_tax_pct:.0f}% \u05e2\u05dc \u05d7\u05dc\u05e7 \u05d4\u05e8\u05d5\u05d5\u05d7 \u05d1\u05dc\u05d1\u05d3).<br>'
                        f'\U0001f4a1 <b>\u05d8\u05d9\u05e4</b>: \u05e9\u05e7\u05d5\u05dc \u05de\u05e9\u05d9\u05db\u05d4 \u05d1\u05e9\u05e0\u05d9\u05dd \u05e9\u05d1\u05d4\u05df \u05d4\u05e8\u05d5\u05d5\u05d7 \u05e0\u05de\u05d5\u05da \u05d9\u05d5\u05ea\u05e8. '
                        f'\u05e7\u05d5\u05e4\u05d5\u05ea \u05d2\u05de\u05dc/\u05e7\u05e8\u05df \u05d4\u05e9\u05ea\u05dc\u05de\u05d5\u05ea \u05de\u05d0\u05e4\u05e9\u05e8\u05d5\u05ea \u05d3\u05d7\u05d9\u05d9\u05ea/\u05e4\u05d8\u05d5\u05e8 \u05de\u05e1.'
                        f'</div>',
                        unsafe_allow_html=True,
                    )
            else:
                st.markdown(
                    '<div class="general-tip">'
                    '\U0001f4c8 <b>\u05e9\u05dc\u05d1 \u05e6\u05d1\u05d9\u05e8\u05d4</b> \u2014 \u05d0\u05d5\u05e4\u05e7 \u05d0\u05e8\u05d5\u05da \u05de\u05d0\u05e4\u05e9\u05e8 \u05d7\u05e9\u05d9\u05e4\u05d4 \u05d2\u05d1\u05d5\u05d4\u05d4 \u05dc\u05de\u05e0\u05d9\u05d5\u05ea. '
                    'DCA (\u05d4\u05e4\u05e7\u05d3\u05d4 \u05d7\u05d5\u05d3\u05e9\u05d9\u05ea) \u05de\u05e4\u05d7\u05d9\u05ea \u05e1\u05d9\u05db\u05d5\u05df \u05ea\u05d6\u05de\u05d5\u05df.'
                    '</div>',
                    unsafe_allow_html=True,
                )
                if monthly == 0:
                    st.info("\U0001f4a1 \u05dc\u05d0 \u05d4\u05d2\u05d3\u05e8\u05ea \u05d4\u05e4\u05e7\u05d3\u05d4 \u05d7\u05d5\u05d3\u05e9\u05d9\u05ea \u2014 \u05d2\u05dd \u05e1\u05db\u05d5\u05dd \u05e7\u05d8\u05df \u05d9\u05e9\u05e4\u05e8 \u05de\u05e9\u05de\u05e2\u05d5\u05ea\u05d9\u05ea \u05d0\u05ea \u05d4\u05ea\u05d5\u05e6\u05d0\u05d4.")

    # ---- General principles ----
    st.markdown("")
    st.markdown("#### \U0001f9ed \u05e2\u05e7\u05e8\u05d5\u05e0\u05d5\u05ea \u05db\u05dc\u05dc\u05d9\u05d9\u05dd")

    tips = [
        ("\U0001f310 \u05d2\u05d9\u05d5\u05d5\u05df", "\u05e9\u05dc\u05d1 \u05de\u05e0\u05d9\u05d5\u05ea, \u05d0\u05d2\u05f4\u05d7, \u05d5\u05e1\u05d7\u05d5\u05e8\u05d5\u05ea \u05dc\u05d4\u05e7\u05d8\u05e0\u05ea \u05e1\u05d9\u05db\u05d5\u05df."),
        ("\u2696\ufe0f \u05d0\u05d9\u05d6\u05d5\u05df \u05de\u05d7\u05d3\u05e9", "\u05e8\u05d1\u05e2\u05d5\u05e0\u05d9/\u05e9\u05e0\u05ea\u05d9 \u05e9\u05d5\u05de\u05e8 \u05e2\u05dc \u05e8\u05de\u05ea \u05d4\u05e1\u05d9\u05db\u05d5\u05df \u05d4\u05e8\u05e6\u05d5\u05d9\u05d4."),
        ("\U0001f4b8 \u05e2\u05dc\u05d5\u05d9\u05d5\u05ea", "\u05d4\u05e2\u05d3\u05e3 ETF \u05e2\u05dd Expense Ratio < 0.2%."),
        ("\U0001f9e0 \u05de\u05e9\u05de\u05e2\u05ea", "\u05d4\u05d9\u05e9\u05d0\u05e8 \u05e2\u05dd \u05d4\u05ea\u05d5\u05db\u05e0\u05d9\u05ea \u05d2\u05dd \u05d1\u05d9\u05e8\u05d9\u05d3\u05d5\u05ea."),
        (f"\U0001f3db\ufe0f \u05de\u05d9\u05e1\u05d5\u05d9", f"{capital_gains_tax_pct:.0f}% \u05de\u05e1 \u05e8\u05d5\u05d5\u05d7\u05d9 \u05d4\u05d5\u05df. \u05e7\u05d5\u05e4\u05f4\u05d2/\u05e7\u05e8\u05df \u05d4\u05e9\u05ea\u05dc\u05de\u05d5\u05ea/IRA \u05de\u05d0\u05e4\u05e9\u05e8\u05d9\u05dd \u05d3\u05d7\u05d9\u05d9\u05ea/\u05e4\u05d8\u05d5\u05e8 \u05de\u05e1."),
    ]

    tip_cols = st.columns(len(tips))
    for j, (title, body) in enumerate(tips):
        with tip_cols[j]:
            st.markdown(
                f'<div class="general-tip" style="text-align:center; min-height:110px;">'
                f'<b>{title}</b><br><span style="font-size:0.85rem; color:#b0b0c0;">{body}</span></div>',
                unsafe_allow_html=True,
            )

    st.caption("\u26a0\ufe0f \u05e0\u05d9\u05ea\u05d5\u05d7 \u05d8\u05db\u05e0\u05d9 \u05d1\u05dc\u05d1\u05d3 \u2014 \u05d0\u05d9\u05e0\u05d5 \u05de\u05d4\u05d5\u05d5\u05d4 \u05d9\u05d9\u05e2\u05d5\u05e5 \u05d4\u05e9\u05e7\u05e2\u05d5\u05ea. \u05d4\u05ea\u05d9\u05d9\u05e2\u05e5 \u05e2\u05dd \u05d9\u05d5\u05e2\u05e5 \u05de\u05d5\u05e1\u05de\u05da.")


# ================================================================
#   Bottom-line Comparison Section
# ================================================================


def render_bottom_line_comparison(all_stats_raw, portfolios_cfg, num_p, ex_rate, cur, tax_rate):
    """
    Bottom-line comparison: NET PROFIT for every portfolio.
    - Accumulation: gain = end_val - total_invested â†’ tax â†’ net_profit.
    - Withdrawal: net_profit = total_withdrawn_net + net_remaining_profit_in_portfolio.
      remaining_profit uses the simulation's tracked cost_basis.
    Also shows estimated annual net return (CAGR) per option.
    """
    if len(all_stats_raw) < 2:
        return

    cur_sym = "â‚ª" if cur == "ILS" else "$"
    tax_pct_display = f"{tax_rate * 100:.0f}%"
    n = min(num_p, len(all_stats_raw))

    # ---- Compute net profit per portfolio ----
    net_profits = []
    tax_totals = []
    total_invested_arr = []
    annual_pcts = []  # net annualized return
    detail_rows = []

    for i in range(n):
        s = all_stats_raw[i]
        phase = portfolios_cfg[i]["phase"]
        end_val = s["end_val"]
        total_invested = s["total_invested"]
        n_years = s.get("n_years", 1)
        is_wd = "××©×™×›×”" in phase or "×¤×¨×™×©×”" in phase

        if is_wd:
            # --- Withdrawal portfolio ---
            cash_net = s.get("total_withdrawn_net", 0)
            ongoing_tax = s.get("total_tax_paid", 0)
            sim_cost_basis = s.get("cost_basis", 0)

            # Remaining gain in portfolio (using simulation's tracked cost_basis)
            remaining_gain = max(end_val - sim_cost_basis, 0)
            final_sale_tax = remaining_gain * tax_rate
            net_remaining_profit = remaining_gain - final_sale_tax

            # Total net profit = net cash withdrawn + net remaining profit
            net_profit = cash_net + net_remaining_profit

            total_tax = ongoing_tax + final_sale_tax
            detail_rows.append({
                "phase_label": "××©×™×›×”",
                "total_invested": total_invested,
                "end_val": end_val,
                "cash_withdrawn_net": cash_net,
                "remaining_gain_net": net_remaining_profit,
                "ongoing_tax": ongoing_tax,
                "final_sale_tax": final_sale_tax,
                "total_tax": total_tax,
                "net_profit": net_profit,
            })
        else:
            # --- Accumulation portfolio ---
            gain = max(end_val - total_invested, 0)
            final_sale_tax = gain * tax_rate
            net_profit = gain - final_sale_tax

            detail_rows.append({
                "phase_label": "×¦×‘×™×¨×”",
                "total_invested": total_invested,
                "end_val": end_val,
                "cash_withdrawn_net": 0,
                "remaining_gain_net": net_profit,
                "ongoing_tax": 0,
                "final_sale_tax": final_sale_tax,
                "total_tax": final_sale_tax,
                "net_profit": net_profit,
            })
            total_tax = final_sale_tax

        # Annualized net return: ((total_invested + net_profit) / total_invested)^(1/n) - 1
        if total_invested > 0 and n_years > 0:
            total_end_net = total_invested + net_profit
            if total_end_net > 0:
                ann_net = ((total_end_net / total_invested) ** (1 / n_years) - 1) * 100
            else:
                ann_net = -100.0
        else:
            ann_net = 0.0

        net_profits.append(net_profit * ex_rate)
        tax_totals.append(total_tax * ex_rate)
        total_invested_arr.append(total_invested * ex_rate)
        annual_pcts.append(ann_net)

    # ---- UI ----
    st.markdown("---")
    st.markdown('<div class="comparison-box">', unsafe_allow_html=True)
    st.markdown("### ğŸ“ ×”×©×•×•××ª ×¨×•×•×— × ×˜×• â€” ×›××” ×‘×××ª ×”×¨×•×•×—×ª?")
    st.caption(f"×¨×•×•×— × ×˜×• = ××©×™×›×•×ª × ×˜×• + ×¨×•×•×— × ×˜×• ×©× ×•×ª×¨ ×‘×ª×™×§ â€” ××—×¨×™ {tax_pct_display} ××¡ ×¨×•×•×—×™ ×”×•×Ÿ")

    # --- Metric cards in portfolio order ---
    metric_cols = st.columns(n)
    best_idx = max(range(n), key=lambda i: net_profits[i])

    for i in range(n):
        d = detail_rows[i]
        badge = " ğŸ‘‘" if i == best_idx else ""
        roi = (net_profits[i] / total_invested_arr[i] * 100) if total_invested_arr[i] > 0 else 0
        with metric_cols[i]:
            st.metric(
                label=f"×¤×•×¨×˜×¤×•×œ×™×• {i+1} ({d['phase_label']}){badge}",
                value=f"{cur_sym}{net_profits[i]:,.0f}",
                delta=f"×ª×©×•××” × ×˜×• ×›×•×œ×œ×ª: {roi:.1f}% | ×©× ×ª×™: ~{annual_pcts[i]:.1f}%",
                help=f"×¡×”×´×› ×”×•×©×§×¢: {cur_sym}{total_invested_arr[i]:,.0f}\n"
                     f"×¡×”×´×› ××¡: {cur_sym}{tax_totals[i]:,.0f}",
            )

    # --- Gap row (if exactly 2) ---
    if n == 2:
        delta = net_profits[0] - net_profits[1]
        delta_pct = (delta / abs(net_profits[1]) * 100) if net_profits[1] != 0 else 0
        ann_diff = annual_pcts[0] - annual_pcts[1]
        winner = f"×œ×˜×•×‘×ª ×¤×•×¨×˜×¤×•×œ×™×• 1 ({detail_rows[0]['phase_label']})" if delta > 0 else f"×œ×˜×•×‘×ª ×¤×•×¨×˜×¤×•×œ×™×• 2 ({detail_rows[1]['phase_label']})"
        g1, g2 = st.columns(2)
        with g1:
            st.metric(
                label="×”×¤×¨×© ×‘×¨×•×•×— ×”× ×˜×• (Î”)",
                value=f"{cur_sym}{abs(delta):,.0f}",
                delta=f"{abs(delta_pct):.1f}% {winner}",
                delta_color="normal" if delta > 0 else "inverse",
            )
        with g2:
            st.metric(
                label="×”×¤×¨×© ×ª×©×•××” ×©× ×ª×™×ª × ×˜×• (Î”)",
                value=f"{abs(ann_diff):.2f}%",
                delta=f"{winner}",
                delta_color="normal" if delta > 0 else "inverse",
            )

    # --- Summary table ---
    st.markdown("")
    st.markdown("#### ğŸ“‹ ×˜×‘×œ×ª ×¡×™×›×•×")

    row_labels = [
        "×¡×”×´×› ×”×•×©×§×¢",
        "×©×•×•×™ ×ª×™×§ ×¡×•×¤×™",
        "××©×™×›×•×ª × ×˜×• (×× ×™×©)",
        "×¨×•×•×— × ×˜×• ×©× ×•×ª×¨ ×‘×ª×™×§",
        f"××¡ ×¢×œ ××©×™×›×•×ª ({tax_pct_display})",
        f"××¡ ×¢×œ ×™×ª×¨×ª ×ª×™×§ ({tax_pct_display})",
        f"×¡×”×´×› ××¡ ({tax_pct_display})",
        "âœ… ×¨×•×•×— × ×˜×• ×›×•×œ×œ",
        "ğŸ“Š ×ª×©×•××” ×©× ×ª×™×ª × ×˜×• ××•×¢×¨×›×ª",
    ]
    table_data = {"××“×“": row_labels}

    for i in range(n):
        d = detail_rows[i]
        table_data[f"×¤×•×¨×˜×¤×•×œ×™×• {i+1} ({d['phase_label']})"] = [
            f"{cur_sym}{d['total_invested'] * ex_rate:,.0f}",
            f"{cur_sym}{d['end_val'] * ex_rate:,.0f}",
            f"{cur_sym}{d['cash_withdrawn_net'] * ex_rate:,.0f}" if d['cash_withdrawn_net'] > 0 else "â€”",
            f"{cur_sym}{d['remaining_gain_net'] * ex_rate:,.0f}",
            f"{cur_sym}{d['ongoing_tax'] * ex_rate:,.0f}" if d['ongoing_tax'] > 0 else "â€”",
            f"{cur_sym}{d['final_sale_tax'] * ex_rate:,.0f}",
            f"{cur_sym}{tax_totals[i]:,.0f}",
            f"{cur_sym}{net_profits[i]:,.0f}",
            f"~{annual_pcts[i]:.2f}%",
        ]

    df_compare = pd.DataFrame(table_data).set_index("××“×“")
    st.dataframe(df_compare, use_container_width=True)

    st.markdown('</div>', unsafe_allow_html=True)


# ================================================================
#   Run Simulation
# ================================================================

st.markdown("---")

if st.button("ğŸš€ ×”×¤×¢×œ ×¡×™××•×œ×¦×™×”", use_container_width=True, type="primary"):

    fig = go.Figure()
    all_display_metrics = []
    all_stats_raw = []
    colors = ["#00d4aa", "#ff6b6b", "#4dabf7"]
    any_data = False

    for idx in range(num_p):
        pcfg = st.session_state.portfolios[idx]
        series, stats = simulate_portfolio(
            pcfg, initial_capital, global_monthly,
            start_year, end_year, freq_map[rebalance_freq],
        )
        if series.empty:
            continue

        any_data = True
        disp = series * exchange_rate

        fig.add_trace(go.Scatter(
            x=disp.index, y=disp.values,
            mode="lines", name=f"×¤×•×¨×˜×¤×•×œ×™×• {idx + 1}",
            line=dict(color=colors[idx % 3], width=2.5),
        ))

        cur = active_currency
        all_display_metrics.append({
            "×¤×•×¨×˜×¤×•×œ×™×•": f"×¤×•×¨×˜×¤×•×œ×™×• {idx + 1}",
            "ğŸ’° ×¡×›×•× ×”×ª×—×œ×ª×™": format_currency(stats["start_val"] * exchange_rate, cur),
            "ğŸ’° ×¡×›×•× ×¡×•×¤×™": format_currency(stats["end_val"] * exchange_rate, cur),
            "ğŸ’° ×¡×”×´×› ×”×•×©×§×¢": format_currency(stats["total_invested"] * exchange_rate, cur),
            "ğŸ“¤ ×¡×”×´×› × ××©×š (×‘×¨×•×˜×•)": format_currency(stats["total_withdrawn_gross"] * exchange_rate, cur),
            "ğŸ›ï¸ ×¡×”×´×› ××¡ ×©×©×•×œ×": format_currency(stats["total_tax_paid"] * exchange_rate, cur),
            "ğŸ’¸ ×¡×”×´×› × ××©×š (× ×˜×•)": format_currency(stats["total_withdrawn_net"] * exchange_rate, cur),
            "ğŸ“ˆ ×ª×©×•××” ×›×•×œ×œ×ª": f"{stats['total_return_pct']:.2f}%",
            "ğŸ“ˆ ×ª×©×•××” ×©× ×ª×™×ª (CAGR)": f"{stats['cagr']:.2f}%",
            "ğŸ“‰ ×ª× ×•×“×ª×™×•×ª ×©× ×ª×™×ª": f"{stats['ann_vol']:.2f}%",
            "âš–ï¸ ×©××¨×¤": f"{stats['sharpe']:.2f}",
            "ğŸ“‰ ×™×¨×™×“×” ××§×¡×™××œ×™×ª": f"{stats['max_dd']:.2f}%",
            "ğŸ”„ ×©×œ×‘": pcfg["phase"],
        })

        all_stats_raw.append(stats)

    if any_data:
        # Comparison graph
        st.markdown("### ğŸ“ˆ ×’×¨×£ ×”×©×•×•××ª ×¤×•×¨×˜×¤×•×œ×™×•")

        # Initial capital line
        fig.add_hline(
            y=initial_capital * exchange_rate,
            line_dash="dash", line_color="gray",
            annotation_text="×¡×›×•× ×”×ª×—×œ×ª×™",
            annotation_position="top left",
        )

        # Mark today if future projection exists
        if is_future:
            fig.add_vline(
                x=datetime.today(), line_dash="dot", line_color="#ffcc00",
                annotation_text="×”×™×•×", annotation_position="top right",
            )

        cur_symbol = "â‚ª" if active_currency == "ILS" else "$"
        fig.update_layout(
            template="plotly_dark", height=520,
            margin=dict(l=20, r=20, t=40, b=20),
            xaxis_title="×ª××¨×™×š", yaxis_title=f"×©×•×•×™ ({cur_symbol})",
            hovermode="x unified",
            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        )
        st.plotly_chart(fig, use_container_width=True)

        # ---- Summary cards per portfolio ----
        st.markdown("### ğŸ“Š ×ª×•×¦××•×ª")

        summary_cols = st.columns(num_p)
        for i, metrics in enumerate(all_display_metrics):
            with summary_cols[i]:
                st.markdown(f'<div class="result-card">', unsafe_allow_html=True)
                st.markdown(f"**×¤×•×¨×˜×¤×•×œ×™×• {i + 1}**")
                st.markdown("</div>", unsafe_allow_html=True)

                st.metric("×¡×›×•× ×”×ª×—×œ×ª×™", metrics["ğŸ’° ×¡×›×•× ×”×ª×—×œ×ª×™"])
                st.metric("×¡×›×•× ×¡×•×¤×™", metrics["ğŸ’° ×¡×›×•× ×¡×•×¤×™"])
                st.metric("×¡×”×´×› ×”×•×©×§×¢ (×›×•×œ×œ ×”×¤×§×“×•×ª)", metrics["ğŸ’° ×¡×”×´×› ×”×•×©×§×¢"])
                st.metric("×ª×©×•××” ×›×•×œ×œ×ª ×œ×ª×§×•×¤×”", metrics["ğŸ“ˆ ×ª×©×•××” ×›×•×œ×œ×ª"])
                st.metric("×ª×©×•××” ×©× ×ª×™×ª ×××•×¦×¢×ª (CAGR)", metrics["ğŸ“ˆ ×ª×©×•××” ×©× ×ª×™×ª (CAGR)"])

                # Show withdrawal & tax info only if there were withdrawals
                if metrics["ğŸ“¤ ×¡×”×´×› × ××©×š (×‘×¨×•×˜×•)"] not in ("$0", "â‚ª0"):
                    st.markdown("---")
                    st.markdown("**ğŸ“¤ ×¤×™×¨×•×˜ ××©×™×›×•×ª ×•××™×¡×•×™:**")
                    st.metric("×¡×”×´×› × ××©×š (×‘×¨×•×˜×•)", metrics["ğŸ“¤ ×¡×”×´×› × ××©×š (×‘×¨×•×˜×•)"])
                    st.metric(f"×¡×”×´×› ××¡ ×¨×•×•×—×™ ×”×•×Ÿ ({capital_gains_tax_pct:.0f}%)", metrics["ğŸ›ï¸ ×¡×”×´×› ××¡ ×©×©×•×œ×"])
                    st.metric("×¡×”×´×› × ××©×š (× ×˜×• ×œ×™×“)", metrics["ğŸ’¸ ×¡×”×´×› × ××©×š (× ×˜×•)"])

        # Full table
        with st.expander("ğŸ“‹ ×˜×‘×œ×ª ××“×“×™× ××œ××”"):
            df_m = pd.DataFrame(all_display_metrics).set_index("×¤×•×¨×˜×¤×•×œ×™×•")
            st.dataframe(df_m, use_container_width=True)

        # ---- Bottom-line comparison (A vs B) ----
        render_bottom_line_comparison(
            all_stats_raw, st.session_state.portfolios,
            num_p, exchange_rate, active_currency, CAPITAL_GAINS_TAX,
        )

        # ---- Recommendations ----
        render_recommendations(all_stats_raw, st.session_state.portfolios, initial_capital, global_monthly)
    else:
        st.error("×œ× × ××¦××• × ×ª×•× ×™×. ×•×“× ×©×‘×›×œ ×¤×•×¨×˜×¤×•×œ×™×• ×™×© × ×›×¡×™× ×ª×§×™× ×™×.")

# ========================
# Footer
# ========================

st.markdown("---")
st.markdown(
    "<div style='text-align:center; color:#888; font-size:0.85rem;'>"
    "×”× ×ª×•× ×™× ××‘×•×¡×¡×™× ×¢×œ ××™×“×¢ ×”×™×¡×˜×•×¨×™ ×‘×œ×‘×“ ×•××™× × ××”×•×•×™× ×”××œ×¦×ª ×”×©×§×¢×”. ×‘×™×¦×•×¢×™ ×”×¢×‘×¨ ××™× × ××‘×˜×™×—×™× ×ª×©×•××” ×¢×ª×™×“×™×ª."
    "</div>",
    unsafe_allow_html=True,
)
